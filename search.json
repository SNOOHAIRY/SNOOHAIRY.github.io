[{"title":"python实现成绩分析并实现可视化","url":"/2020/12/25/python实现成绩分析并实现可视化/","content":"# 写在前面\n\n小班的高数段考成绩出来了，惨不忍睹，于是我想可视化看看到底有多惨...\n\n代码有点凌乱，因为直接在`Jupyter`上想到啥就瞎敲的啥,以下也是`ipynb`文件直接转换过来的，（有时间再整理一下叭，毕竟关键代码也就十行左右）转换代码(在cmd里执行就可)：\n\n```cmake\njupyter nbconvert --to markdown 成绩分析.ipynb\n```\n\n----------我是分割线-----------\n\n```python\nnum = [67,73,66,21,58,61,41,75,69,68,54,49,60,79,61,30,76,69,67,24,82,61,40,71,80,77,82,60,87,71,69,81,69,61,67,0,71]\n```\n\n导入成绩\n\n\n```python\nfrom collections import Counter\ncnt = Counter(num)\nprint(cnt)\n```\n\n    Counter({61: 4, 69: 4, 67: 3, 71: 3, 60: 2, 82: 2, 73: 1, 66: 1, 21: 1, 58: 1, 41: 1, 75: 1, 68: 1, 54: 1, 49: 1, 79: 1, 30: 1, 76: 1, 24: 1, 40: 1, 80: 1, 77: 1, 87: 1, 81: 1, 0: 1})\n\n\n\n```python\nlenn = len(cnt)\nprint(lenn)\n```\n\n    25\n\n\n\n# 分数段展示（以5为单位）\n\n\n```python\nimport matplotlib.pyplot as plt\nimport re\nx = []\ny = []\nun = 0\ns = 0\nse = 0\nei = 0\nni = 0\n# 间隔为10\nccc = [0,0,0,0,0,0,0,0,0,0,0]\n# 间隔为5\ncf = [0 for i in range(0,20)]\nfor i,j in cnt.items():\n    # print(i,j)\n    \n    x.append(i)\n    y.append(j)\n    \n    # print(i,\":\",j)\n    \n    ccc[(int)(i/10)] += j;\n    cf[(int)(i/5)] +=j;\nfor i in range(20):\n    if(cf[i]!=0):\n        print(i*5,'~',(i+1)*5-1,':',cf[i])\n    # if(i<60): un = un + j\n    # elif(i<70): s = s + j\n    # elif(i<80): se = se + j\n    # elif(i<90): ei = ei + j\n# print(\"60分以下人数：\",un,\"\\n60～69分人数：\",s,\"\\n70～79分人数：\",se,\"\\n80～89分人数：\",ei,\"\\n90分以上人数：\",ni)    \n```\n\n    0 ~ 4 : 1\n    20 ~ 24 : 2\n    30 ~ 34 : 1\n    40 ~ 44 : 2\n    45 ~ 49 : 1\n    50 ~ 54 : 1\n    55 ~ 59 : 1\n    60 ~ 64 : 6\n    65 ~ 69 : 9\n    70 ~ 74 : 4\n    75 ~ 79 : 4\n    80 ~ 84 : 4\n    85 ~ 89 : 1\n\n\n# 设置表格的横纵坐标范围\n```python\nx_major_locator=MultipleLocator(10)\ny_major_locator=MultipleLocator(1)\n\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.xlim(0,100)\nplt.ylim(0,10)\n```\n\n\n```python\nplt.bar(x,y)\nplt.figure()\nplt.show()\n\nplt.bar(yi,ccc)\nplt.figure()\nplt.show()\n\nx_major_locator=MultipleLocator(10)\ny_major_locator=MultipleLocator(1)\n\n#ax为两条坐标轴的实例\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.xlim(0,100)\nplt.ylim(0,10)\n\nplt.bar(yii,cf, alpha=0.9, width = 5, facecolor = 'yellowgreen', edgecolor = 'white', label='one', lw=1)\nplt.show()\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202012252102121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n    `<Figure size 432x288 with 0 Axes>`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210306964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n\n\n    <Figure size 432x288 with 0 Axes>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210328224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n\n\n# 具体人数显示\n\n\n```python\nimport numpy as np\nyi = [0,10,20,30,40,50,60,70,80,90,100]\nplt.plot(yi,ccc)\nplt.show()\n\nyii = np.arange(0,100,5)\n\nprint(yii)\n\nplt.plot(yii,cf)\nplt.show()\n\nx,y=zip(*sorted(zip(x,y)))\nfor i in range(lenn):\n    print(x[i],\":\",y[i])\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210346727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n\n    [ 0  5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210357951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n    0 : 1\n    21 : 1\n    24 : 1\n    30 : 1\n    40 : 1\n    41 : 1\n    49 : 1\n    54 : 1\n    58 : 1\n    60 : 2\n    61 : 4\n    66 : 1\n    67 : 3\n    68 : 1\n    69 : 4\n    71 : 3\n    73 : 1\n    75 : 1\n    76 : 1\n    77 : 1\n    79 : 1\n    80 : 1\n    81 : 1\n    82 : 2\n    87 : 1\n\n\n# 成绩段分布图\n\n\n```python\nfrom matplotlib.pyplot import MultipleLocator\nx,y = zip(*sorted(zip(x,y)))\nx_major_locator=MultipleLocator(10)\ny_major_locator=MultipleLocator(1)\nax=plt.gca()\n#ax为两条坐标轴的实例\nax.xaxis.set_major_locator(x_major_locator)\n#把x轴的主刻度设置为1的倍数\nax.yaxis.set_major_locator(y_major_locator)\n#把y轴的主刻度设置为10的倍数\n\n# plt.plot(x,y)\nplt.title('成绩段分布图')\nplt.xlabel('分数')\nplt.ylabel('人数')\nplt.plot(yii,cf)\n# plt.plot(x,y)\n\n#把x轴的刻度范围设置为0到100，如果设置不满一个刻度的数，可以看到一点空白\nplt.xlim(0,100)\n#把y轴的刻度范围设置为0到10\nplt.ylim(0,10)\n\nplt.show()\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210419891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n\n\n# 可以忽略的一部分\n\n```python\nflag = 0\nfullx = []\nfully = []\n\n# 填充每一个成绩，每一个刻度为0 \nfor i,j in cnt.items():\n    if(flag < i):\n        for number in range(i-flag,3):\n            fullx.append(flag+number)\n            fully.append(0)\n        fullx.append(i)\n        fully.append(j)\n        flag = i+1\n    else:\n        fullx.append(i)\n        fully.append(j)\n        flag = i+1\nfullx,fully=zip(*sorted(zip(fullx,fully)))\n\nplt.plot(fullx,fully)\nx_major_locator=MultipleLocator(10)\ny_major_locator=MultipleLocator(1)\nax = plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.xlim(0,90)\nplt.ylim(0,5)\nplt.show()\nultipleLocator(10)\ny_major_locator=MultipleLocator(1)\nax = plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.xlim(0,90)\nplt.ylim(0,5)\nplt.show()\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225210629484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2ODU4,size_16,color_FFFFFF,t_70)\n\n"},{"title":"Learning in the Frequency Domain     --频域学习","url":"/2020/10/24/Learning in the Frequency Domain     --频域学习/","content":"# Learning in the Frequency Domain     --频域学习\n\n\n\n核心：省略图像压缩/解压缩中计算量最大的步骤，**直接利用频域特征来进行图像推理**，减少系统中模块之间的数据传输量，从而提升系统性能。\n\n### Abstract\n\n平常的图片会很大，并且必须被**下采样**[^1]到神经网络的预定输入大小。\n\n[^1]: 缩小图像（或称为下采样（`subsampled`）或降采样（`downsampled`））的主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。**下采样原理：**对于一幅图像I尺寸为M*N，对其进行s倍下采样，即得到(M/s)*(N/s)尺寸的得分辨率图像，当然s应该是M和N的公约数才行，如果考虑的是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值.\n\n尽管下采样操作减少了计算量和所需的通信带宽，但它会明显地去除冗余和显著的信息，从而导致精度下降。\n\n基于学习的频率选择方法来识别可以在不损失精度的情况下去除的微小频率分量。\n\n实验表明，采用静态信道选择的频域学习方法比较传统的空间喜爱采样方式具有更高的精度，同时进一步减少了输入数据量。\n\n### Introduction\n\n论文建议在频域（即离散余弦变化域）对高分辨率图像进行整形，而不是在空间域调整它们的大小，然后将整形后的离散余弦变换系数反馈给CNN模型进行推理\n\n实验结果表明，在输入数据大小相等或更小的情况下，与传统的基于RGB的方法相比，我们的方法在图像分类、目标检测和实例分割任务中获得了更高的精度。所提出的方法导致所需芯片间通信带宽的直接减少，这通常是现代深度学习推理系统中的瓶颈，即快速发展的AI加速器/GPU的计算吞吐量正变得越来越高，超过CPU的数据加载吞吐量，如图1所示\n\n![image-20201024070538673](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201024070538673.png)\n\n<center>使用RGB图像作为输入的传统的基于CNN的方法的工作流程。使用离散余弦变换系数作为输入的拟议方法的工作流程。CB代表CPU和GPU/加速器之间所需的通信带宽。</center>\n\n受人类视觉系统`(HVS)`对不同频率分量的敏感度不相等的观察的启发，论文分析了频域中的图像分类、检测和分割任务，发现CNN模型对低频信道比高频信道更敏感，这与`HVS`相一致。这一观察结果通过基于学习的通道选择方法得到验证，该方法由多个“开关”组成。**具有相同频率的离散余弦变换系数被打包成一个通道，每个开关被堆叠在一个特定的频率通道上，以允许整个通道流入或不流入网络。**\n\n从数据传输和计算的角度来看，使用解码的高保真图像进行模型训练和推理提出了重大挑战。由于CNN模型的频谱偏差，人们只要**在推理过程中保持重要的频道**，就不会失去准确性。在本文中，我们还开发了一种**静态信道选择方法**来保留显著信道，而不是使用整个频谱进行推理。实验结果表明，当输入数据量减少87.5%时，神经网络模型仍然保持相同的准确率。\n\n### 为什么在频域上学习？\n\n计算资源和内存是有限制的，大多数卷积神经网络模型，只能接受低分辨率的RGB图像（如 224*224）因此，总是要经过一个压缩的过程\n\n图像输入(In)通常是RGB的空间域信号，在编码端经过RGB-to-YCbCr的转化、离散余弦变换(DCT)、量化(Quantization)， 以及熵编码(Entropy coding)，得到压缩后用来传输的信号。\n\n### 节省计算量：用频域信息进行机器学习\n\n在整个图像分析系统中，除去最后的图像推理引擎，前期的压缩、传输、解压缩的瓶颈在于其中的DCT和IDCT模块，因为这两个变换是矩阵变换，而其他的操作基本都是基于点的操作。\n\n若是能够减少，甚至省略这两个模块，将会对图像分析系统的前半部分带来极大的性能提升，也就是说，输入到神经网络的数据，将不再是RGB颜色空间，而是YCbCr颜色空间。\n\n以Y通道为例，假设图像压缩标准中默认的8×8作为块的尺寸(blocksize)。那么，对于每一个块(block)，就会得到64个DCT的信号，对应了64个不同的频率分量。\n\n若原始图像的尺寸是W x H，那么将会有W/8 x H/8 个DCT信号组成的块。每个块中相同位置的频率分量可以组成一个尺寸为W/8 x H/8的特征图片(feature map)，这样就会产生8×8=64个特征图片。\n\n同样的对于Cb和Cr通道，也可以各自产生64个特征图片，共计64×3=192个，如下图所示。\n\n![image-20201024080538242](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201024080538242.png)\n\n<center>频域学习的数据预处理流水线</center>\n\n让**特征图片的尺寸和神经网络的尺寸吻合**\n\n以ResNet-50为例，通常接受的图片输入尺寸为224×224，经过一次卷积层(stride=2)和池化之后，网络的特征图尺寸为56×56，和产生的频率信号特征图尺寸吻合。\n\n可以将192个56×56的频域特征图，全部或者部分直接接在ResNet-50的第一个残差块(Residue Block)之前，从而达到**不改变ResNet-50的结构，却实现从频域做机器识别的目的**，如图所示：\n\n![image-20201024082218155](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201024082218155.png)\n\n值得注意的是，由于做了8×8的DCT变换，实际输入的图片大小为448×448，**是标准ResNet-50输入的两倍**。\n\n### 节省带宽：频域信息重要性提取\n\n**节省带宽**也是性能提高的方法，因为某些频率通道对推断准确性具有更大的影响。\n\n所以，**只保留那些最重要的频率通道**，并将它们传输到GPU/AI加速器进行推理，是可行的。\n\n这一步是通过在机器学习中添加gate的方法，来学习每一个特征图片的重要性。\n\n在训练中，不仅能得出用于图像推理的神经网络中的权重，同时每一个特征图的重要性也被确定。\n\n![image-20201024083729296](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201024083729296.png)\n\n现在拥有了选择重要的频率通道的方式。有两种方案来减少从图像解码模块到图像推理引擎的数据带宽，分别是动态(Dynamic)方式和静态(Static)方式。\n\n所谓动态方式，就是每一个频率分量的选择开关由当前输入的图像决定，这种方法可以自适应每一次图像推理(inference)的不同输入。\n\n而静态方式，就是通过训练（training）得到最重要的一些频率分量。\n\n这种静态方式在推理的时候无需选择开关的网络，不仅可以节省图像解码模块到图像推理引擎的带宽，还可以在编码模块中忽略不重要的频率分量，进而减少图像编码的计算量、延时，以及网络传输的带宽。\n\n他们提出的实验结果表明，静态方式下，输入数据量减少87.5%，CNN 模型仍能保持相同的精度。\n\n![img](http://p3.pstatp.com/large/pgc-image/9c9a13779f314a34ac65f70f7039ff72)\n\n总的来说，就是利用频域特征来进行图像推理，从而省略频域到空间域的转换，因为这个转换是图像压缩/解压缩中计算量最大的步骤。\n\n同时可以在频域选择重要的信息，进一步减少系统中模块之间的数据传输量，从而提升整个系统的性能。\n\n所以结果如何？\n\n## 精度更高，输入数据量却减少\n\n实验主要在**图像分类**和**实例分割**——两个极具代表性的机器学习任务进行。\n\n在图像分类任务中，采用ImageNet(ILSVRC-2012)作为数据集，ResNet-50和MobileNetV2作为CNN模型。\n\n经过训练，得到了一张不同频率分量重要性的热力图，描述了对应192个频率分量的重要性程度。\n\n![image-20201030170806634](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201030170806634.png)\n\n可以看出，Y(亮度)通道的重要性高于Cb和Cr通道，同时低频分量的重要性高于高频分量。\n\n这样，就可以利用“频域学习”方法，一次训练了解如何分配带宽资源。\n\n![img](http://p1.pstatp.com/large/pgc-image/8ec70b39a91e439795e92419415742e8)\n\n从结果可以看出，与基线 ResNet-50相比，使用所有频率通道时，Top-1准确率提高了1.4% 。\n\n值得注意的是，DCT-48和 DCT-24分别选择了48和24个频率通道，输入数据大小分别相当于基线 ResNet-50的一半。\n\n对于只有一半输入数据大小的 DCT-24来说，Top-1的精度仍然提高了约1% 。\n\n再用MobileNetV2作为基准CNN模型，采用同样的原理做实验，得到结果如下：\n\n\n\n![img](http://p1.pstatp.com/large/pgc-image/5d6f07dbe0744c0c9596ece8584a4d65)\n\n选择32和24个频率通道时，Top-1准确率分别提高了0.664% 和0.58% 。\n\n对于实例分割任务，采用了COCO数据集，并使用Mask R-CNN作为深度神经网络结构，训练得到的192个频率分量的热力图如下：\n\n![image-20201030165151852](C:\\Users\\hpdso\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201030165151852.png)\n\n实验结果表明，当输入数据大小相等(DCT-48)或较小(DCT-24)时，该方法优于基于RGB的Mask R-CNN 基线。\n\n![img](http://p1.pstatp.com/large/pgc-image/7509958f60f9487599821a1c933ffa84)\n\nDCT-48，可以提升大约0.8%的精度(37.3%到38.1% 以及 34.2%到35.0%)。DCT-24，即输入数据大小减少一半的情况，让bbox AP 和 Mask AP的性能分别提高了0.4。\n\n应用到COCO数据集中，实际分割图像是这样的：![img](http://p3.pstatp.com/large/pgc-image/84c559a76d45477687775fec31ba53b8)\n\n\n\n\n\n源码地址：https://github.com/calmevtime/DCTNet\n\n"},{"title":"正则表达式匹配（动态规划）","url":"/2020/06/21/正则表达式匹配（动态规划）/","content":"今日题解---动态规划\n\n\n\n[10 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n\n\n`dp[i][j]` 是否能被前`dp[i-1][j-1]`匹配\n\n"},{"title":"验证回文串","url":"/2020/06/19/验证回文串/","content":"\n## [125  验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n\n### 题目描述\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n**说明：**本题中，我们将空字符串定义为有效的回文串。\n\n**示例 1:**\n\n```\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n```\n\n**示例 2:**\n\n```\n输入: \"race a car\"\n输出: false\n```\n\n### 题解\n\n每次在`leetcode`都能遇到神奇的解法\n\n#### 【转换字母大小写】\n\n```c\nch & 0b11011111  //ch & 0xDF  ---全部转换为大写\nch | 0b00100000  //ch & 0x20  ---全部转换为小写\n```\n\n---来自 `simplehippo`的评论\n\n这里自己想了一下，真是巧妙，因为小写和大写字母刚好相差32，而32就是二进制下的第5位，与上第5位的0相当于减32，或上第5位的1则相当于加上32，妙，妙就完事了。\n\n（65--‘A'   97--'a'）\n\n#### 【关于这一题回文串的想法】\n\n这里最直接的想法就是从最左到最右进行匹配，向中间缩进，匹配成功则是回文串，反之则不是。（目前还没想到什么比较快的思路）\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        int l = 0,r = s.length()-1;\n        while(l<=r){\n            while((0 == isalnum(s[l])) && l<r) ++l;   //isalnum()判断是否是数字或者是字母,返回0则不是字母也不是数字,数字返回值是1,字母返回值是2\n            while((0 == isalnum(s[r])) && r>l) --r;\n            if(tolower(s[r]) != tolower(s[l])) return false;\n            ++l,--r;\n        }\n       return true;\n    }\n};\n```\n\n","tags":["leetcode"],"categories":["题解"]},{"title":"python中包的使用 from /import /as","url":"/2020/06/10/python中包的使用-from-import-as/","content":"\n### python中包的使用\n\n#### 包的基本配置\n\n在python中包的引入首先得是个包（这不是废话吗），一个包就得有个包的样子（比如包的标配，目录中必须包含 `__init__.py`文件，当然内容也可为空）\n\n...这里就不过多的废话了\n\n#### 包的导入\n\n包的导入方式有：\n\n##### `import...`\n\n```python\n# 导入名为 os 的包，使用path类中的get_path方法\nimport os\npath = os.path.get_path()\n```\n\n##### `from...import...`\n\n```python\n# 从包 data 中导入 read_image 这个类，即可直接使用\nfrom data import read_image\npath = ' '\nimg = read_image(path)\n```\n\n##### `import...as...`\n\n```python\n# 使用 time 这个时间类，并给ta取个别名 timer\nimport time as timer\n# 使用同上\n```\n\n","tags":["python"],"categories":["python"]},{"title":"第一二章知识点回顾","url":"/2020/05/11/第一章第二章知识总结/","content":"\n### 🎈第一章\n\n资源抽象：方便用户使用（方便性）\n\n虚化，复用\n\n#### ⭐操作系统的特性\n\n**并发性**：指一个处理器通过是处理多个事件（两个或两个以上事件同一时刻发生）。\n\n【与并行的区别】：并行是指多个处理器或多核处理器同时处理不同的事件。\n\n**共享性**：与并发性为依存关系\n\n**异步性**\n\n**虚拟性**\n\n#### 🪐三种操作系统 \n\n**批处理系统**：（一批批执行）没有交互\n\n**分时系统**：划分事件片终端，解决交互信息需求\n\n**实时系统**：满足需要得到实时响应的需求\n\n#### 🌫多道处理系统\n\n多道程序：中断（支持进程切换），通道\n\n多道处理系统与系统开销无关\n\n#### ⚡一些概念\n\n**系统调用:** 只是一种`API`\n\n**陷入指令：**中断（内中断，外中断）\n\n### 🎈第二章\n\n1.寄存器\n\n2.机器指令\n\n3.处理器状态\n\n4.`PSW`寄存器:储存当前数据（CPU)，程序执行的中间状态，记录刚执行的位置\n\n5.`PSW`字:储存下一条指令\n\n#### 关于中断\n\n时钟中断：进程切换\n\n中断的发生是异步的\n\n中断：打断处理器正常的工作\n\n中断之后回来不一定继续作业（可能返回断点，可能重新开始一个作业）\n\n外设准备好再向CPU发送中断信号\n\n外中断可以屏蔽（有优先级）\n\n内中断不可屏蔽，一旦出现立即响应并处理\n\n中断回到下一条指令\n\n异常回到当前指令（未结束的情况下->缺页中断）","tags":["操作系统"],"categories":["操作系统"]},{"title":"触发器","url":"/2020/05/08/触发器/","content":"\n### 定义触发器\n\n当特定的系统事件（如对表进行的增、删、改操作，事物的结束等）发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。[^触发器又叫做事件-条件-动作规则]\n\n**`SQL`使用`CREATE TRIGGER`命令建立触发器**,一般格式为：\n\n```sql\nCREATE TRIGGER <触发器名>  \t\t\t\t/*每当触发器事件发生时，该触发器被激活*/\n{BEFORE|AFTER} <触发器事件> ON <表名> \t/*指明触发器激活的时间是在执行触发器事件前还是后*/\nREFERENCING NEW|OLD ROW AS <变量> \t\t/*REFERENCING指出引用的变量*/\nFOR EACH{ROW|STATEMENT} \t\t\t\t/*定义触发器的类型，指明动作执行的频率*/\n[WHERE <触发器条件>] <触发器动作体> \t\t/*仅当触发器条件为真时才执行触发动作体*/\n```\n\n关于触发器类型，稍后再说...\n\n","tags":["数据库"],"categories":["数据库"]},{"title":"继承方式简介","url":"/2020/05/05/继承方式简介/","content":"\n## 继承方式简介\n\n### 不同继承方式的影响主要体现在：\n\n​\t\t**派生类成员**对基类成员的访问权限\t\n\n​\t\t通过**派生类对象**对基类成员的访问权限\n\n#### 三种继承方式\n\n[公有继承](#公有继承)，[私有继承](#私有继承)，[保护继承](#保护继承)\n\n### 公有继承\t\n\n#### \t继承的访问控制\n\n​\t\t\t基类的`public`和`protected`成员：访问属性在派生类中保持不变；\n\n​\t\t\t基类的`private`成员：不可直接访问。\n\n#### \t访问权限：\n\n​\t\t\t派生类中的成员函数：可以直接访问基类中的`public`和`protected`成员，但不能直接访问基类的`private`成员；\n\n​\t\t\t通过派生类的对象：只能访问`public`成员\n\n#### \t🌰举个栗子\n\n`Point.h`\n\n```c++\n#ifndef _POINT_H\n#define _POINT_H\nclass Point {   \n    //基类Point类的定义\n    public:     \n    //公有函数成员\n        void initPoint(float x = 0, float y = 0){ \n            this->x = x; \n            this->y = y;\n        }\n        void move(float offX, float offY){ \n            x += offX; \n            y += offY;\n        }\n        float getX() const { return x; }\n        float getY() const { return y; }\n    private:        \n    //私有数据成员\n        float x, y;\n};\n#endif //_POINT_H\n```\n\n`Rectangle.h`\n\n```c++\n#ifndef _RECTANGLE_H\n#define _RECTANGLE_H\n#include \"Point.h\"\nclass Rectangle: public Point { \n//派生类定义部分\npublic: \n//新增公有函数成员\n    void initRectangle(float x, float y, float w, float h) {\n        initPoint(x, y);              //调用基类公有成员函数\n        this->w = w;\n        this->h = h;\n    }\n    float getH() const { return h; }\n    float getW() const { return w; }\nprivate:    \n//新增私有数据成员\n    float w, h;\n};\n#endif //_RECTANGLE_H\n```\n\n`main.cpp`\n\n```c++\n#include <iostream>\n#include <cmath>\nusing namespace std;\n#include “Rectangle.h”\nint main() \n{\n    Rectangle rect; //定义Rectangle类的对象\n    //设置矩形的数据\n    rect.initRectangle(2, 3, 20, 10);   \n    rect.move(3,2); //移动矩形位置\n    cout << \"The data of rect(x,y,w,h): \" << endl;\n    //输出矩形的特征参数\n    cout << rect.getX() <<\", \"\n        << rect.getY() << \", \"\n        << rect.getW() << \", \"\n        << rect.getH() << endl;\n    return 0;\n}\n```\n\n\n\n### 私有继承\n\n#### \t继承的访问控制：\n\n​\t\t\t基类的`public`和`protected`成员：都以`private`身份出现在派生类中；\n\n​\t\t\t基类的`private`成员：不可直接访问。\n\n#### \t访问权限：\n\n​\t\t\t派生类中的成员函数：可以直接访问基类中的`public`和`protected`成员，但不能直接访问基类的`private`成员；\n\n​\t\t\t通过派生类的对象：不能直接访问从基类继承的任何成员。\n\n#### \t🌰举个栗子\n\n`延用上一个Point.h`\n\n`Rectangle.h`\n\n```c++\n#ifndef _RECTANGLE_H\n#define _RECTANGLE_H\n#include \"Point.h\"\nclass Rectangle: private Point {    //派生类定义部分\npublic: //新增公有函数成员\n    void initRectangle(float x, float y, float w, float h) {\n        initPoint(x, y); //调用基类公有成员函数\n        this->w = w;\n        this->h = h;\n    }\n    void move(float offX, float offY) {   Point::move(offX, offY);  }\n    float getX() const { return Point::getX(); }\n    float getY() const { return Point::getY(); }\n    float getH() const { return h; }\n    float getW() const { return w; }\nprivate:    //新增私有数据成员\n    float w, h;\n};\n#endif //_RECTANGLE_H\n```\n\n`main.cpp`\n\n```c++\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() \n{\n    Rectangle rect; //定义Rectangle类的对象\n    rect.initRectangle(2, 3, 20, 10);   //设置矩形的数据\n    rect.move(3,2); //移动矩形位置\n    cout << \"The data of rect(x,y,w,h): \" << endl;\n    cout << rect.getX() <<\", \"  //输出矩形的特征参数\n        << rect.getY() << \", \"\n        << rect.getW() << \", \"\n        << rect.getH() << endl;\n    return 0;\n}\n```\n\n\n\n### 保护继承\n\n","tags":["C++"],"categories":["C++"]},{"title":"类的继承和派生","url":"/2020/05/04/类的继承和派生/","content":"\n## 继承和派生概述\n\n继承和派生是同一过程从不同角度看：\n\n​\t\t**保持已有类的特性**而构造新类的过程称为**继承**。\n\n​\t\t在已有类的基础上**新增自己的特性**而产生新类的过程称为**派生**。\n\n### 父类和子类\n\n​\t\t**被继承的已有类称为基类**（或**父类**）\n\n​\t\t**派生出的新类称为派生类**（或**子类**）\n\n### 直接基类和简介基类\n\n​\t\t**直接参与派生出某类的基类**称为**直接基类**\n\n​\t\t**基类的基类甚至更高层的基类**称为**间接基类**\n\n### 语法\n\n#### 🌰单继承\n\n```c++\nclass 派生类名:继承方式 基类名{\n\t成员声明;\n}\n//example:\nclass Derived:public Base{  //一个新类Derived继承了Base类,继承方式是public\n    public:\n    Derived(); //构造函数\n    ~Derived(); //析构函数\n}\n```\n\n#### 🌰多继承\n\n```c++\nclass 派生类名:继承方式1 基类名1,继承方式2 基类名2,...{\n    成员声明;\n}\n//注意：每一个继承方式，只用于限制对紧跟其后的基类的继承\n//example:\nclass Derived:public Base1,private Base2{ //此时Derived继承了两个基类Base1,Base2;Base1以public的方式继承，Base2以private的方式继承\n    public:\n    Derived();\n    ~Derived();\n}\n```\n\n继承可以继承父类原有成员，也可对原有成员（若同名，则新成员会隐藏或覆盖外层同名成员）进行改变，也可新增成员（数据成员，函数成员等）。\n\n#### 📢注：\n\n默认情况下，派生类包含了全部基类中除构造和析构函数之外的所有成员；\n\nC++11规定可以用`using`语句继承基类构造函数。","tags":["C++"],"categories":["C++"]},{"title":"类中成员的类型","url":"/2020/04/27/类中成员的类型/","content":"\n### public（公有类型成员）\n\n在关键字public后面声明，她们是类与外部的接口，任何外部函数都可以访问共有类型数据和函数。\n\n### private（私有类型成员）\n\n在关键字private后面声明，只能允许本类中的函数访问，而类外部的任何函数都不能访问。\n\n如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。（也就是**在缺省的情况下，成员类型为私有**）\n\n```c++\nclass A{\n\tint a; //此时a为私有成员\n\tpublic:\n\tint b;\n\tchar c; //b,c为共有成员\n}\n```\n\n### protect （保护类型成员）\n\n","tags":["C++"],"categories":["C++"]},{"title":"数组中重复的数字","url":"/2020/04/26/面试题03.-数组中重复的数字/","content":"\n## [面试题03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n\n### 题目描述\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 `nums` 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n**示例 1：**\n\n```\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n```\n\n**限制：**\n\n```\n2 <= n <= 100000\n```\n\n题目出自`《剑指offer(第二版)》`\n\n### 题目解析\n\n最直接的解法就是创建一个大小相同的记录数组，因为数组中的数字均有范围，即可适用哈希来进行标注。讲出现过的数字对应的下表标注是否出现过，若遍历过程中出现了，则直接返回结果。\n\n```c++\nclass Solution {\npublic:\n    int findRepeatNumber(vector<int>& nums) {\n        bool flag[nums.size()];\n        memset(flag,false,sizeof(flag));\n        for(int i=0;i<nums.size();i++){\n            if(flag[nums[i]]) return nums[i];\n            else flag[nums[i]]=true;\n        }\n        return -1;\n    }\n};\n```\n\n","tags":["leetcode"],"categories":["题解"]},{"title":"指令系统","url":"/2020/04/23/指令系统/","content":"\n## 一.指令系统的发展和性能要求\n\n### 1.指令系统的发展\n\n#### (1)指令（机器指令）的定义\n\n​\t是指要求计算机执行某种操作的命令，是计算机硬件能够直接识别和执行的二进制机器代码，又称机器指令。\n\n#### (2)指令系统\n\n​\t一台计算机的所有的指令结合成为该机的指令系统和指令集。\n\n#### (3)系统计算机\n\n​\t是指具有相同的基本指令系统和基本体系结构，但具有不同组合和实现的一系列不同型号的机器。\n\n\n\n### 2.一条指令应包含如何信息：\n\n#### \t(1)进行何种操作\n\n​\t\t即操作性质。体现再指令中被成为**操作码**。\n\n#### \t(2)操作的对象\n\n​\t\t数据来源以及如何寻找操作数。体现在指令中被成为**地址码**。\n\n#### \t(3)操作的结果\n\n​\t\t指令操作结果存放何处。\n\n#### \t(4)下一条指令定位 \n\n​\t\t下一条指令的起始地址，一般由PC指示 `只有跳转指令需要`\n\n​\t\t**program count** (程序计数器 PC=？)\n\n### 3.对指令系统性能的要求\n\n#### \t完备性\n\n​\t\t指要求指令系统功能完备\n\n#### \t有效性\n\n\n\n#### \t规整性\n\n​\t\t包括对称性、匀齐性、指令格式和数据格式的一致性。\n\n​\t\n\n## ⭐二.指令格式\n\n### 1.地址码\n\n按地址码的多少，指令一般可以分为（固定操作码长）：\n\n#### 🟤三地址指令 \n\n​\tOP A1 A2 A3\n\n[^OP]: 指令集\n[^A1 A2 A3]: 地址\n\n​\t指令功能一： A1 OP A2->A3\n\n#### 🟤二地址指令 \n\n​\tOP A1 A2\n\n#### 🟤一地址指令 \n\n​\tOP A1 \n\n#### 🟤零地址指令\n\n​\tOP","tags":["计算机组成原理"],"categories":["计算机组成原理"]},{"title":"Typora使用笔记","url":"/2020/04/23/Typora使用笔记/","content":"\n## 1.更改字体以及展示宽度\n\n新建一个`github.user.css`文件，然后输入：以下代码即可，注意：默认主题为github主题，该文件代表覆盖github主题，进一步的自定义可以参考[Typora官方主题文档](http://theme.typora.io/doc/)\n\n```\n/* 默认字体替换为微软雅黑 */\nbody {\n    font-family: \"Microsoft YaHei\";\n}\n \n/* 默认表格字体改为等宽字体 */\ntable {\n    font-family: Consolas;\n}\n \n/* 编辑界面最大宽度设置为自适应 */\n#write{\n    max-width: 90%;   \n}\n\n/* 源码界面最大宽度设置为自适应 */\n#typora-source .CodeMirror-lines {\n   max-width: 90%;\n}\n```\n\n这一步的参考博客为[使用第三方Markdown编辑器编辑为知笔记](https://www.jianshu.com/p/e1baaea15458)\n\n## 2. Typora的快捷键\n\n由于使用的是Markdown语法，所以Markdown的格式这里均适用\n\n**\n\n| 操作                     | 快捷键                                                   |\n| ------------------------ | -------------------------------------------------------- |\n| 表格                     | CTRL+T 即可弹出窗口，选择几行几列就可创建表格            |\n| 字体加粗                 | 直接选中CTRL+B  or  ** **里面的字体即为加粗格式          |\n| 代码块                   | CTRL+SHIFT+K  or  ``` 后面再加上同样的符号即为结束代码块 |\n| 引用                     | >                                                        |\n| 指向链接（Markdown语法） | `[]()`第一个方括号里面填文字，第二个圆括号里填写链接     |\n\n...此处省略一堆快捷键，有时间再更新😀\n\n## 3. 模式选择\n\n> 1.**打字机模式（Typewriter Mode)**：光标置于屏幕中央\n>\n> 2.**沉浸模式（Focus Mode）**：除了书写行，其余行变暗\n\n🍳模式选择在视图(view)中可以找到\n\n## 4.导出文件\n\n我用得最多的当然是原始的.md格式的文件，但是出于好奇心我点了导出为word，在Typora的指引下去[pandoc的GitHub网址](https://github.com/jgm/pandoc/releases/tag/2.9.2.1)下载了pandoc。\n\n这时候问题来了，我明明按照指引安了pandoc,但是我要导出.docx文件的时候还是提醒我去下载。于是乎，我打开了命令行cmd，在安装的目录下输入\n\n```\npandoc --help\n```\n\n然后下面是一大堆的操作帮助，再打开pandoc的时候就忽然可以顺利导出word了。\n\n📢显然效果很好，出乎我的意料，夸！","tags":["Typora"],"categories":["Typora"]},{"title":"类的友元","url":"/2020/04/22/类的友元/","content":"\n## 一 .\t友元关系（friend）\n\n### 1.\t为什么会有友元关系\n\n类中私有和保护的成员在类外不能被访问。而若是想在类B中嵌入类A的对象，此时B的成员函数是无法直接访问A的私有成员的。从数据安全的角度来说，这无疑是最安全的，因为内嵌的部件相当于一个黑盒。\n\n其中的不便显而易见：下列例子实现形式就会出现编译错误。\n\n```c++\nvoid B::set(int i){\n\ta.x=i;\n}\n```\n\n这时候，友元函数就体现出了它的作用。先来看看**友元关系**是啥?\n\n### 2.\t友元关系能实现什么\n\n友元关系提供了不同类和对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。**也就是说，通过友元关系，一个普通函数或者类的成员函数可以访问封装于另一个类中的数据。**虽然这是对数据隐蔽和封装的破坏，但这实现了数据的共享。\n\n在类中，用关键字**friend**将函数或类声明为友元。友元是一般函数或类的成员函数，称为友元函数；是类，则成为友元类，**友元类的所有成员函数都自动成为友元函数。**\n\n### 3. \t友元关系如何声明\n\n声明一般格式为:\n\n```c++\nfriend <type> FuncName(<args>);\n```\n\n友元函数不是成员函数，用法和普通函数完全一致。\n\n","tags":["C++"],"categories":["C++"]},{"title":"关系代数和SQL课堂测试","url":"/2020/04/20/关系代数和SQL课堂测试/","content":"\n### 第一关\n{% post_link 关系代数和SQL课堂测试第一关 %}\n### 第二关\n{% post_link 关系代数和SQL课堂测试第二关 %}\n### 第三关\n{% post_link 关系代数和SQL课堂测试第三关 %}\n### 第四关\n{% post_link 关系代数和SQL课堂测试第四关 %}\n","tags":["数据库"],"categories":["homeword"]},{"title":"安装好的hexo发布本地博客到GitHub","url":"/2020/04/19/安装好的hexo发布本地博客到GitHub/","content":"\nWelcome to [My blogs](https://SNOOHAIRY.github.io/)!\n\n注意，以下的每一步操作都在你的本地博客文件目录下执行\n\n## [Hexo](https://hexo.io/zh-cn/)预览本地博客文件\n\n### 预览本地博客 \n调用cmd在命令行输入hexo安装的位置 再输入命令\n\n```bash\nhexo s -p 1234\n```\n这里的1234是本地地址，可以通过浏览器访问：http://localhost:1234 通过编写本地.md文件，保存之后刷新浏览器即可看到预览效果。\n\n当然如果选择自己的本地博客目录在空白处右键选择 Git Bash Here,输入\n```bash\nhexo s\n```\n就会分配一个默认的地址 http://localhost:4000 ,复制到浏览器也可浏览\n\n### 关于hexo的配置过程 稍后更新。\n\n## [Hexo](https://hexo.io/zh-cn/)发布本地博客到GitHub\n\n如果打开了本地预览要先关闭本地预览文件（ctrl+c），然后在命令行中敲入\n```bash\nhexo g\n```\n```bash\nhexo d\n```\n然后会有提示输入Github的用户名，输入Github的账户密码 点击login即可更新同步。\n如果期间出现了问题，执行hexo g的时候出现错误,可能是没有安装hexo-deployer-git 在命令行输入\n```bash\nnmp install hexo-deployer-git --save\n```\n再执行一次前两个命令即可\n若又出现 something's wrong....\n```bash\nRun\n    git config --global user.email\"you@example.com\"\n    git config   global user.name\"Your Name\"\n    ...\n```\n则分别复制 把\"\"里的提示词分别改成你的邮件和用户名即可，注意是你申请github时用的邮件和用户名。\n然后回车再输入开始的两个操作，输入hexo -d会有一个github的登录界面，登录即可。\n\n再回到你的github博客网址刷新就可以看到你编写的博客啦。","tags":["hexo"],"categories":["hexo"]},{"title":"hello-world","url":"/2020/04/04/hello-world/","content":"---\nHELLO WORLD\n---\nWelcome to [My blogs](https://SNOOHAIRY.github.io/)!\n\n```bash\ncout<<\"hello world\"<<endl;\n```"}]